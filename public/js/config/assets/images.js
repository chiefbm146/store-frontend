/**
 * Images Configuration
 * Central registry for all image paths in the application
 *
 * This file:
 * - Maps all images from brand, services, products, and pages configs
 * - Provides helper functions to get image paths
 * - Generates list for asset preloader
 *
 * NOTE: This file can be auto-generated by reading other configs.
 * For now, it's manually maintained but structured for automation.
 */

// Import other configs to extract images
import { brand } from '../core/brand.js';
import { services } from '../content/services.js';
import { products } from '../content/products.js';
import { pageContent } from '../content/pages.js';

// ===== IMAGE REGISTRY =====
export const images = {
    // ===== BRAND IMAGES =====
    brand: {
        // Logos
        logoMain: brand.logos.main,
        logoDark: brand.logos.mainDark,
        logoLight: brand.logos.mainLight,
        logoIcon: brand.logos.icon,
        logoHorizontal: brand.logos.horizontal,
        logoVertical: brand.logos.vertical,

        // Favicons
        faviconSvg: brand.logos.faviconSvg,
        faviconPng: brand.logos.faviconPng,
        appleTouchIcon: brand.logos.appleTouchIcon,

        // Social/OG images
        ogImage: brand.logos.ogImage,
        ogImageSquare: brand.logos.ogImageSquare,
        twitterImage: brand.logos.twitterImage,
    },

    // ===== SERVICE IMAGES =====
    // Auto-populated from services config
    services: {},

    // ===== PRODUCT IMAGES =====
    // Auto-populated from products config
    products: {},

    // ===== PAGE IMAGES =====
    pages: {
        // About page
        aboutHero: pageContent.about?.hero?.image,
        aboutMission: pageContent.about?.sections?.find(s => s.id === 'mission')?.image,
        aboutVision: pageContent.about?.sections?.find(s => s.id === 'vision')?.image,

        // Founder page
        founder: pageContent.founder?.image,

        // Menu page featured sections
        newArrivals: pageContent.menu?.featuredSections?.[0]?.image,
        bestSellers: pageContent.menu?.featuredSections?.[1]?.image,
        specialOffers: pageContent.menu?.featuredSections?.[2]?.image,
    },

    // ===== PLACEHOLDER IMAGES =====
    placeholders: {
        service: "/images/placeholders/service.jpg",
        product: "/images/placeholders/product.jpg",
        person: "/images/placeholders/person.jpg",
        logo: "/images/placeholders/logo.png",
    },
};

// Auto-populate service images
Object.keys(services).forEach(serviceId => {
    const service = services[serviceId];
    images.services[serviceId] = service.image;

    // Also collect gallery images
    if (service.gallery && service.gallery.length > 0) {
        images.services[`${serviceId}-gallery`] = service.gallery;
    }
});

// Auto-populate product images
Object.keys(products).forEach(productId => {
    const product = products[productId];
    images.products[productId] = product.image;

    // Also collect gallery images
    if (product.gallery && product.gallery.length > 0) {
        images.products[`${productId}-gallery`] = product.gallery;
    }
});

// ===== HELPER FUNCTIONS =====

/**
 * Get all unique image paths (for preloading)
 */
export function getAllImagePaths() {
    const paths = new Set();

    // Helper to recursively extract string paths
    function extractPaths(obj) {
        if (typeof obj === 'string' && obj.startsWith('/images/')) {
            paths.add(obj);
        } else if (Array.isArray(obj)) {
            obj.forEach(item => extractPaths(item));
        } else if (obj && typeof obj === 'object') {
            Object.values(obj).forEach(value => extractPaths(value));
        }
    }

    // Extract from all sections
    extractPaths(images);

    return Array.from(paths).filter(path => path && path !== 'null');
}

/**
 * Get brand images only
 */
export function getBrandImages() {
    return Object.values(images.brand).filter(path => path && path !== 'null');
}

/**
 * Get service images only
 */
export function getServiceImages() {
    const paths = [];

    Object.values(images.services).forEach(value => {
        if (typeof value === 'string') {
            paths.push(value);
        } else if (Array.isArray(value)) {
            paths.push(...value);
        }
    });

    return paths.filter(path => path && path !== 'null');
}

/**
 * Get product images only
 */
export function getProductImages() {
    const paths = [];

    Object.values(images.products).forEach(value => {
        if (typeof value === 'string') {
            paths.push(value);
        } else if (Array.isArray(value)) {
            paths.push(...value);
        }
    });

    return paths.filter(path => path && path !== 'null');
}

/**
 * Get page images only
 */
export function getPageImages() {
    return Object.values(images.pages).filter(path => path && path !== 'null');
}

/**
 * Get image path for a service
 */
export function getServiceImage(serviceId) {
    return images.services[serviceId] || images.placeholders.service;
}

/**
 * Get image path for a product
 */
export function getProductImage(productId) {
    return images.products[productId] || images.placeholders.product;
}

/**
 * Preload priority images (critical for first paint)
 */
export function getPriorityImages() {
    return [
        images.brand.logoMain,
        images.brand.ogImage,
        images.pages.aboutHero,
        // Add any other critical images
    ].filter(path => path && path !== 'null');
}

/**
 * Get all images for preloading (with priority handling)
 */
export function getPreloadImages(options = {}) {
    const {
        includeBrand = true,
        includeServices = true,
        includeProducts = true,
        includePages = true,
        limit = null, // Limit total images (for performance)
    } = options;

    const paths = [];

    // Priority images first
    if (includeBrand) {
        paths.push(...getBrandImages());
    }

    if (includeServices) {
        paths.push(...getServiceImages());
    }

    if (includeProducts) {
        paths.push(...getProductImages());
    }

    if (includePages) {
        paths.push(...getPageImages());
    }

    // Remove duplicates and nulls
    const uniquePaths = [...new Set(paths)].filter(path => path && path !== 'null');

    // Apply limit if specified
    if (limit && uniquePaths.length > limit) {
        return uniquePaths.slice(0, limit);
    }

    return uniquePaths;
}

/**
 * Check if image exists in registry
 */
export function hasImage(imagePath) {
    const allPaths = getAllImagePaths();
    return allPaths.includes(imagePath);
}

/**
 * Get fallback image for type
 */
export function getFallbackImage(type) {
    return images.placeholders[type] || images.placeholders.product;
}

// Export default
export default images;
